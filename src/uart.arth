#define UART_RX_BUFFER_MASK  (UART_RX_BUFFER_SIZE - 1)
#define UART_TX_BUFFER_MASK  (UART_TX_BUFFER_SIZE - 1)

#if CPU == "atmega8"
	#define UART_DATA			UDR
	#define UART_STATUS		UCSRA
	#define UART_RXC			RXC
	#define UART_TXC			TXC
	#define UART_CONTROL		UCSRB
	#define UART_CONTROLC	UCSRC
	#define UART_U2X			U2X
	#define UART_RXCIE		RXCIE
	#define UART_RXEN			RXEN
	#define UART_TXEN			TXEN
	#define UART_UBRRL		UBRRL
	#define UART_UBRRH		UBRRH
	#define UART_CONTROLC_VAL bitmask(URSEL, UCSZ0, UCSZ1)
#elif CPU == "atmega328"
	#define UART_DATA			UDR0
	#define UART_STATUS		UCSR0A
	#define UART_RXC			RXC0
	#define UART_TXC			TXC0
	#define UART_STATUS		UCSR0A
	#define UART0_CONTROL	UCSR0B
	#define UART0_CONTROLC	UCSR0C
	#define UART_U2X			U2X0
	#define UART_RXCIE		RXCIE0
	#define UART_RXEN			RXEN0
	#define UART_TXEN			TXEN0
	#define UART_UBRRL		UBRR0L
	#define UART_UBRRH		UBRR0H
	#define UART_CONTROLC_VAL	 bitmask(UCSZ00, UCSZ01)
#else
	#error "Unsupported MCU"
#endif


var UART_TxHead: byte
var UART_TxTail: byte
var UART_RxHead: byte
var UART_RxTail: byte
var UART_TxBuf: byte[UART_TX_BUFFER_SIZE]
var UART_RxBuf: byte[UART_RX_BUFFER_SIZE]


;**************************************************************************
; Function: UART Data Register Empty interrupt
; Purpose:  called when the UART is ready to transmit the next byte
;**************************************************************************
proc usart_udre_vect() {
	saveregs (ZL, ZH, SREG) {
		ZH = UART_TxHead
		ZL = UART_TxTail
		if (ZH == ZL) {
			UCSRB->UDRIE = 0		; tx buffer empty, disable UDRE interrupt
		} else {
			; calculate and store new buffer index
			ZL++
			ZL &= UART_TX_BUFFER_MASK
		
			UART_TxTail = ZL
			; get one byte from buffer and write it to UART
			ZH = 0						; Z = tmptail
			Z += UART_TxBuf
		
			UDR = r30 = mem[Z]			; UART_TxBuf[tmptail]
		}
	}
	reti
}



;*************************************************************************
; Function: UART Receive Complete interrupt
; Purpose:  called when the UART has received a character
;**************************************************************************
proc usart_rxc_vect() {
	saveregs(r24, ZL, ZH, SREG) {
		; calculate buffer index
		ZL = UART_RxHead + 1
		r24 = UART_RxTail
	
;		if (r24 == ZL) {
;			ZH = 2		; ZH = UART_BUFFER_OVERFLOW
;		} else {
		if (r24 != ZL) {
			UART_RxHead = ZL
			ZH = 0
			Z += UART_RxBuf
			mem[Z] = r24 = UDR
;			ZH = UCSRA & bitmask(FE, DOR, UPE)			; read UART status register, lastRxError = usr & (_BV(FE)|_BV(DOR) );
; FE: Ошибка кадра. 
;	устанавливается при обнаружении условий ошибочного приема кадра, т.е. когда стоповый бит входящего символа в состоянии 0. Бит FE очищается при приеме стопового бита с логическим уровнем 1.
; DOR: Переполнение данных. 
;	устанавливается при обнаружении условий переполнения, т.е. когда байт уже находящийся в регистре UDR, не считан перед пересылкой нового байта из сдвигового регистра приема. Бит DOR буферирован, что означает, что он будет оставаться установленным, пока не будут считаны правильные данные из UDR. Бит DOR очищается  когда данные приняты и пересланы в UDR.
; UРЕ: Ошибка контроля четности. 
;	устанавливается, если данных, находящихся в буфере приемника, выявлена ошибка контроля четности. При отключенном контроле четности бит постоянно равен 0.

		}
;		UART0_LastRxError = r24 = UART0_LastRxError | ZH
	}
	reti
}


;*************************************************************************
; Function: uart_putc()
; Purpose:  write byte to ringbuffer for transmitting via UART
; Input:    byte to be transmitted
; Returns:  none
;**************************************************************************
proc uart_put_byte(b: r24) {	; портит Z
	; uint8_t tmphead = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
	ZL = UART_TxHead + 1
	ZL &= UART_TX_BUFFER_MASK
	
	; Ждём появление свободного места в буфере
	loop {								; while (tmphead == UART_TxTail)
		ZH = UART_TxTail
		if (ZH != ZL) break
	}
	;UART_TxBuf[tmphead] = data;
	ZH = 0
	UART_TxHead = ZL
	Z += UART_TxBuf
	mem[Z] = r24

	UCSRB->UDRIE = 1			; enable UDRE interrupt
	ret
}


proc uart_put_hex_nibble(v: r24) {
	v &= 0b1111
	if (v < 10) {
		v += '0'
	} else {
		v += 'A' - 10
	}
	rjmp	uart_put_byte	
}

proc uart_put_hex_byte(b: r24) {
	push	r24
	swap	r24
	rcall	uart_put_hex_nibble(r24)
	pop	r24
	rjmp	uart_put_hex_nibble(r24)
}

;proc uart_wait_word() { ; -> r25.r24, портит r3, r2, r30, r31
;	rcall	uart_wait_byte
;	r1 = r0
;}


;; портит Z, r3, r3
;proc uart_wait_byte() { ; -> r0
;	use r2 as head
;	; waiting data ready
;	ZL = UART_RxTail
;	loop {
;		ZH = UART_RxHead
;		if (ZH != ZL) break
;	}
;
;    ; calculate buffer index
;;    uint16_t tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
;	ZL++
;;	ZH &= 1
;	ZH = 0
;	UART_RxTail = ZL
;
;	; get data from receive buffer
;	; data = UART_RxBuf[tmptail]
;	Z += UART_RxBuf
;	r0 = mem[Z]
;	ret
;}

;proc uartDataIsReady() {	; возвращает SREG->Z = 0, если в UART есть готовые данные для чтения
;	use r2 as head	
;	use ZL as tail
;	
;	tail = UART_RxTail
;	head = UART_RxHead
;	cp		r2, ZL
;;	cpc	r3, r31
;
;	ret
;}



inline proc uart_init() {
	; Init UART
	#if UART_DOUBLE_SPEED
		UART_STATUS->UART_U2X = 1
	#else
		UART_STATUS->UART_U2X = 0
	#endif
	UART_UBRRH = r16 = high(UART_UBRR)
	UART_UBRRL = r16 = low(UART_UBRR)
	UART_CONTROL = r16 = bitmask(UART_RXCIE, UART_RXEN, UART_TXEN)
	UART_CONTROLC = r16 = UART_CONTROLC_VAL

	UART_TxHead = regZero	;r16 = 0		; TODO use r0
	UART_TxTail = regZero	;r16
	UART_RxHead = regZero	;r16.r16
	UART_RxTail = regZero;	r16.r16
}